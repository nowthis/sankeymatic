<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SankeyMATIC &alpha;</title>
<style>

body {
    font-family: sans-serif;
    font-size: small;
    background-color: #F8FDFF;
}

.errormessage {
    background-color: pink;
    color: #660000;
    border: 1px solid red;
    padding: 4px;
    margin: -1px;
}

.cautionmessage {
    background-color: #FFFFAA;
    color: #CC6600;
    border: 1px solid darkorange;
    padding: 4px;
    margin: -1px;
}

.okmessage {
    text-align: center;
    background-color: #DDEEFF;
    color: #003366;
    border: 1px solid #006699;
    padding: 4px;
    margin: -1px;
}

dfn {
    font-style: normal;
    border-bottom: 1px dotted;
}

#entirety, #inputs, #credits {
  margin: 0px auto;
  display:table;
}


textarea#flows_in {
	border: 1px solid #006699;
    padding: 3px;
    margin: 4px;
	font-family: sans-serif;
	font-size: small;
}

p#chart {
    width: 700px;
    height: 400px;
    border: 1px dotted #666666;
    text-align: center;
    color: #006699;
    margin: 10px auto;
    background-color: white;
}

.node rect {
  cursor: move;
  fill-opacity: .9;
  shape-rendering: crispEdges;
}

.node text {
  pointer-events: none;
  text-shadow: 0 1px 0 #fff;
}

/* GRAY links between nodes. fill should be nonexistent; stroke is all. */
.link {
  fill: none;
  stroke: #666;
  stroke-opacity: .3;
}

/* style for all of the svg label text: */
svg { font: 12px sans-serif; }

td { vertical-align: top; padding: 2px;}

td#other_entry {
    padding: 2px;
    background-color: #DDEEFF;
}

td#grapharea {
    padding: 0px;
    margin: 0px;
}

/* cellspacing 0 */
table { border-collapse: collapse; border-spacing: 0; }


th#title {
    padding: 5px 10px;
    background-color: #88BBCC;
    font-size: large;
}

td#flows_entry
{
    padding: 2px;
    background-color: #BBDDEE;
    text-align: center;
    padding: 5px;
    vertical-align: middle;
}

</style>
</head>
<body>

<!-- script src="http://d3js.org/d3.v2.min.js?2.9.1"></script -->
<script src="d3.v2.js"></script>
<script src="sankey.js"></script>
<script>
function isNumeric(n) {
    // borrowed from jquery:
    /* "parseFloat NaNs numeric-cast false positives (null|true|false|"")
       ...but misinterprets leading-number strings, particularly hex literals ("0x...")
       subtraction forces infinities to NaN" */
    return n - parseFloat( n ) >= 0;
}

function escapeHtml(unsafe) {
    return unsafe
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

function remove_zeroes(number_string) {
    // Strip off zeros from after any decimal.
    // If no digits remain, remove the '.' as well.
    return number_string.replace( /(\.\d*?)0+$/, '$1' )
        .replace( /\.$/, '');
}

function process_sankey() {
    "use strict";
    var source_lines = [], good_flows = [], good_node_lines = [],
        bad_lines = [], node_order = [],
        line_ix = 0, line_in = '',
        unique_nodes = {}, matches = [], amount_in = 0;
    var messages_el = document.getElementById('messages_area');
    var raw_flows_var = document.getElementById('flows_in').value;
    var approved_nodes = [], approved_flows = [], approved_config = {};
    var total_inflow = 0, total_outflow = 0, max_places = 0;
    var status_message = '', total_difference = 0;

    // Define utility functions:
    // Put a message on the page using the specified class:
    function add_message( msg_class, msg_html, at_beginning ) {
        var new_msg = '<p class="' + msg_class + '">' + msg_html + '</p>';
        if (at_beginning) {
            messages_el.innerHTML = new_msg + messages_el.innerHTML;
        } else {
            messages_el.innerHTML = messages_el.innerHTML + new_msg;
        }
    }

    // Format a value as it will be in the graph. Uses approved_config and
    // max_places
    function unit_fy(number_in) {
        var number_portion = d3.format( ",." + max_places + "f" )(number_in);
        return approved_config.unit_prefix
            + ( approved_config.display_full_precision
                ? number_portion
                : remove_zeroes(number_portion) )
            + approved_config.unit_suffix;
    }

    // BEGIN by clearing all messages:
    messages_el.innerHTML = '';

    // Go through lots of validation with plenty of bailout points and
    // informative messages for the poor soul trying to do this.

    // Flows validation:

    // parse into structures: approved_nodes, approved_flows, approved_config
    source_lines = raw_flows_var.split("\n");

    // parse all the input lines, storing good ones vs bad ones:
    for ( line_ix = 0; line_ix < source_lines.length; ++line_ix ) {
        // Does this line match the basic format?
        line_in = source_lines[line_ix].trim();
        // Is it a comment? Skip it entirely:
        if ( line_in.match(/^#/) ) {
            continue;
        }
        // Is it a node spec?
        if ( ( matches = line_in.match(
                /^:(.+) #([0-9A-F]{0,6})?(\.\d{1,4})?\s*(>>|<<)*\s*(>>|<<)*$/i ) )
                !== null ) {
            good_node_lines.push(
                { 'name' : matches[1].trim(),
                  'color' : matches[2],
                  'opacity' : matches[3],
                  'inherit1' : matches[4],
                  'inherit2' : matches[5]
                } );
            continue;
        }
        matches = line_in.match( /^(.+)\[([\d\.\s\+\-]+)\](.+)$/ );
        if ( matches !== null ) {
            // The Amount looked like a number; is it really (after tossing out whitespace)?
            amount_in = matches[2].replace(/\s/g,'');
            if ( !isNumeric(amount_in) ) {
                bad_lines.push (
                    { 'value' : line_in,
                      'message' : 'The Amount is not a valid decimal number.' } );
            } else if (amount_in < 0) {
                // The Sankey library doesn't currently support negative numbers:
                bad_lines.push (
                    { 'value' : line_in,
                      'message' : 'Amounts must be positive.' } );
            } else {
                // All seems well, save it as good (even if 0):
                good_flows.push(
                    { 'source' : matches[1].trim(),
                      'target' : matches[3].trim(),
                      'amount' : amount_in } );
                // We need the maximum precision of the inputs (# of characters
                // to the RIGHT of the decimal) for some error checking
                // operations (& display) later:
                max_places =
                    Math.max( max_places,
                        ( ( amount_in.split( /\./ ) )[1] || '' ).length );
            }
        } else if ( line_in !== '' ) {
            // There was input, but something made it not match the pattern:
            bad_lines.push(
                { 'value' : line_in,
                  'message' :
                    'The line is not in the format: Source [Amount] Target' }
            );
        }
        // else, the final case: a blank line. We just skip those silently, so
        // someone can separate their input lines with whitespace if desired.
    }

    // TODO: Look for cycles and post errors about them
    // TODO: Look for 0s and post errors about them

    // Mention the bad lines in the message area:
    bad_lines.forEach(function(parse_error) {
        add_message('errormessage',
            '&quot;<b>' + escapeHtml(parse_error.value) + '</b>&quot;: ' +
             parse_error.message, 0);
    });

    // save_node: Add a node to the unique list (if it's not there already):
    function save_node( nodename, nodeparams = {} ) {
        // Have we NOT seen this node before? Then add it:
        if ( !(nodename in unique_nodes) ) {
            // establish the hash:
            unique_nodes[nodename] = {
                "from_sum": 0,   "to_sum": 0,
                "from_list": [], "to_list": [],
                "index": node_order.length
            };
            node_order.push(nodename);
        }
        // Even if we have seen a node, there still may be more parameters
        // to add to its spec:
        Object.keys(nodeparams).forEach( function(p) {
            // console.log(nodename, p,
            //    unique_nodes[nodename].hasOwnProperty(p) );
            if ( nodeparams[p] !== null && nodeparams[p] !== "" ) {
                // Note: If there are multiple lines specifying the same
                // param for a node, the last one will win:
                unique_nodes[nodename][p] = nodeparams[p];
            }
        } );
    }

    // First go through the Node list and set up any extra parameters we have:
    good_node_lines.forEach( function(node) {
        // If there's a color and it's a color CODE, put back the #:
        if ( node.color && node.color.match( /[0-9A-F]{3,6}/i ) ) {
            node.color = '#' + node.color;
        }
        save_node( node.name, node );
    } );

    // Given good_flows, make the lists of nodes and flows
    good_flows.forEach( function(flow) {
        // Look for extra content about this flow on the target-node end of the
        // string:
        var possible_color, possible_nodename, flow_color = "",
            opacity = "", opacity_on_hover = "";
        // Try to parse; there may be extra info that isn't actually the name:
        // Format of the Target node can be:
        // TODO: Target node ["Custom name for flow"] [#color[.opacity]]
        // e.g. Clinton #CCDDEE
        // e.g. Gondor "Legolas" #998877.25
        // Look for an additional string starting with # for color info
        matches = flow.target.match( /^(.+)\s+(\#\S+)$/ );
        if ( matches !== null ) {
            // IFF the # string matches the pattern, separate the nodename
            // into parts. Assume a color will have at least 3 numbers (rgb).
            possible_nodename = matches[1];
            possible_color    = matches[2];
            matches = possible_color.match(
                /^#([0-9A-F]{3,6})?(\.\d{1,4})?$/i );
            if ( matches !== null ) {
                // We got matches; rewrite the node & interpret the extra data
                flow.target = possible_nodename;
                // Was there a color spec?
                if ( matches[1] ) {
                    flow_color = '#' + matches[1];
                }
                // Was there an opacity argument?
                if ( matches[2] ) {
                    opacity = matches[2];
                    // Make the hover opacity halfway between opacity and 1:
                    opacity_on_hover = ( Number(opacity) + 1 ) / 2;
                }
            }
            // Otherwise we just treat it as part of the nodename
        }
        save_node(flow.source);
        save_node(flow.target);

        // Add the encoded flow to the list of approved flows:
        approved_flows.push({
            "source": unique_nodes[flow.source].index,
            "target": unique_nodes[flow.target].index,
            "value": flow.amount,
            "color": flow_color,
            "opacity": opacity,
            "opacity_on_hover": opacity_on_hover
            }
        );
        // Save useful information for the flow cross-check:
        unique_nodes[flow.source].from_sum += Number(flow.amount);
        unique_nodes[flow.source].from_list.push(flow.amount);
        unique_nodes[flow.target].to_sum += Number(flow.amount);
        unique_nodes[flow.target].to_list.push(flow.amount);
    });

    // Construct the approved_nodes structure:
    node_order.forEach( function (nodename) {
        var this_node = unique_nodes[nodename];
        var readynode = {
            "name": nodename,
            "index": this_node.index,
            "color": this_node.color,
            "opacity": this_node.opacity,
            "inherit_right":
                ( this_node.inherit1 === ">>"
                    || this_node.inherit2 === ">>" ? 1 : 0 ),
            "inherit_left":
                ( this_node.inherit1 === "<<"
                    || this_node.inherit2 === "<<" ? 1 : 0 )
        };

        // approved_nodes = the real node list, formatted for the render routine:
        approved_nodes.push(readynode);
    });

    // Get & fill in the config.
    // Why now? For one thing, we need the Units for the messages we make below.
    // First fill in basic defaults. Values from the form will override if present.
    approved_config = {
        unit_prefix: "",
        unit_suffix: "",
        max_places: max_places,
        display_full_precision: 0,
        include_values_in_nodes: 0,
        hide_labels: 0,
        canvas_width: 700,
        canvas_height: 400,
        font_size: 12,
        top_margin: 10, right_margin: 10, bottom_margin: 10, left_margin: 10,
        default_flow_opacity: 0.3,
        default_node_opacity: 0.9
    };

    // Plain strings:
    (["unit_prefix", "unit_suffix"]).forEach( function(field_name) {
        var field_val = document.getElementById(field_name).value;
        // console.log(field_name, field_val);
        if (field_val.length < 10) {
            approved_config[field_name] = field_val;
        }
    });
    // Whole positive numbers:
    (["canvas_width", "canvas_height", "font_size",
        "top_margin","right_margin", "bottom_margin",
        "left_margin"]).forEach( function(field_name) {
        var field_val = document.getElementById(field_name).value;
        // console.log(field_name, field_val);
        if (field_val.length < 10 && field_val.match(/^\d+$/)) {
            approved_config[field_name] = field_val;
        }
    });
    // Checkboxes:
    (["display_full_precision","include_values_in_nodes",
        "hide_labels"]).forEach( function(field_name) {
        approved_config[field_name] = document.getElementById(field_name).checked;
        // console.log(field_name, approved_config[field_name]);
    });
    // Decimal:
    (["default_node_opacity","default_flow_opacity"]).forEach( function(field_name) {
        var field_val = document.getElementById(field_name).value;
        if ( field_val.match(/^\d(?:.\d+)?$/) ) {
            approved_config[field_name] = field_val;
        }
        // console.log( field_name, field_val, approved_config[field_name] );
    });

    // Given the canvas size, adjust the size of the containing element:
    var chart_el = document.getElementById('chart');
    chart_el.style.height = approved_config.canvas_height + "px";
    chart_el.style.width = approved_config.canvas_width + "px";

    // Flow cross-check: Test if the total INTO a node is equal to the amount
    // OUT OF it; warn the user if not:
    node_order.forEach( function(nodename) {
        var this_node = unique_nodes[nodename], difference;
        // Skip any nodes with 0 as the From or To amount; those are the
        // starting & ending nodes for the whole graph:
        if ( this_node.from_sum > 0 && this_node.to_sum > 0) {
            difference = this_node.to_sum - this_node.from_sum;
            // Is the difference great enough to matter? (i.e. bigger than 1/10
            // the smallest unit used?)
            if ( Math.abs(difference) >=
                Math.pow( 10,-max_places - 1 ) ) {
                // Construct a hyper-informative error message about the
                // imbalance.
                // If we don't round the outputs to match the maximum precision
                // of the inputs, we get uselessly long repeated decimals:
                add_message( "cautionmessage",
                    "&quot;<b>" + escapeHtml(nodename) + "</b>&quot;: " +
                    "The amount <strong>in</strong> (" +
                    '<dfn title="' +
                    this_node.to_list.join(' + ') + '">' +
                    unit_fy(this_node.to_sum) +
                    "</dfn>) does not match the amount <strong>out</strong> (" +
                    '<dfn title="' +
                    this_node.from_list.join(' + ') + '">' +
                    unit_fy(this_node.from_sum) +
                    "</dfn>). &Delta; = <strong>" +
                    unit_fy(difference) + "</strong>.", 0 );
            }
        } else {
            // One of these values will be 0 every time, but so what...
            total_inflow += this_node.from_sum;
            total_outflow += this_node.to_sum;
        }
    });

    // Are there any good flows at all? If not, offer help:
    if ( good_flows.length === 0 ) {
        add_message('okmessage',
            'Enter a list of flows (one per line). See the Examples page.', 0);
        // No point in proceeding any further:
        return null;
    }

    status_message = "Showing: <strong>" + approved_flows.length +
        " flows</strong> between <strong>" + approved_nodes.length +
        " nodes</strong>.";
    total_difference = total_inflow - total_outflow;
    if ( Math.abs(total_difference) < Math.pow( 10,-max_places - 1 ) ) {
        status_message +=
            " Total <strong>In</strong> = Total <strong>Out</strong> = <strong>"
            + unit_fy(total_inflow) + "</strong>.";
    } else {
        // Leave out the differing totals from the status message, issue a
        // Caution instead:
        add_message( "cautionmessage",
            "The <strong>Total In</strong> (" +
            unit_fy(total_inflow) +
            ") does not match the <strong>Total Out</strong> (" +
            unit_fy(total_outflow) +
            "). &Delta; = <strong>" + unit_fy(total_difference) + "</strong>.",
            0 );
    }
    add_message( "okmessage", status_message, 1 ); // always display main status line first

    // Finally, do the actual rendering:
    return render_sankey( approved_nodes, approved_flows, approved_config );
}

function render_sankey(nodes_in, flows_in, config_in) {
    "use strict";

    var graph_width, graph_height,
        units_format, d3_color_scale, svg, sankey, flow, link, node,
        node_width = 15, node_padding = 10,
        total_width   = config_in.canvas_width,
        total_height  = config_in.canvas_height,
        margin_top    = config_in.top_margin,
        margin_bottom = config_in.bottom_margin,
        margin_left   = config_in.left_margin,
        margin_right  = config_in.right_margin;

    config_in.unit_prefix =
        ( typeof config_in.unit_prefix === "undefined"
            || config_in.unit_prefix === null )
            ? "" : config_in.unit_prefix;
    config_in.unit_suffix =
        ( typeof config_in.unit_suffix === "undefined"
            || config_in.unit_suffix === null)
            ? "" : config_in.unit_suffix;

    // Establish a list of 20 compatible colors to choose from:
    d3_color_scale = d3.scale.category20();

    // Fill in any missing node colors up front so they can be inherited from:
    nodes_in.forEach( function(node) {
        if (typeof node.color === 'undefined' || node.color === '') {
            // Use the first word of the label as the basis for
            // finding an already-used color or picking a new one (case
            // sensitive).
            // If there are no 'word' characters, substitute a word-ish value
            // (rather than crash):
            var first_word = ( /^\W*(\w+)/.exec(node.name) || ['','not a word'] )[1];
            node.color = d3_color_scale(first_word);
        }
    });

    var the_clean_json = {
        "nodes": nodes_in,
        "links": flows_in
    };

    // Set the dimensions of the space:
    graph_width = total_width - margin_left - margin_right;
    graph_height = total_height - margin_top - margin_bottom;

    // *&*&*&* TODO: Does this function really need to be assigned to a variable?
    units_format = function (d) {
        var number_portion = d3.format( ",." + config_in.max_places + "f" )(d);
        return config_in.unit_prefix
            + ( config_in.display_full_precision
                ? number_portion
                : remove_zeroes(number_portion) )
            + config_in.unit_suffix;
    };

    // clear out any old contents:
    // Simply emptying the SVG tag didn't work well in Safari; we reset the whole tag here:
    document.getElementById('chart').innerHTML =
        '<svg id="the_svg" height="400" width="700" xmlns="http://www.w3.org/2000/svg" version="1.1"></svg>';
    // Apply the font size setting now:
    document.getElementById('the_svg').style.fontSize = config_in.font_size + "px";

    // Select the svg canvas, set the defined dimensions:
    svg = d3.select("#the_svg")
        .attr("width", total_width)
        .attr("height", total_height)
        .append("g")
        .attr("transform", "translate(" + margin_left + "," + margin_top + ")");

    // create a sankey object & its properties..
    sankey = d3.sankey()
        .nodeWidth(node_width)
        .nodePadding(node_padding)
        .size([graph_width, graph_height])
        .nodes(the_clean_json.nodes)
        .links(the_clean_json.links)
        .layout(32);

    // flow is a function returning coordinates and specs for each flow area
    flow = sankey.link();

    link = svg.append("g").selectAll(".link")
        .data(the_clean_json.links)
        .enter()
        .append("path")
        .attr("class", "link")
        .attr("d", flow) // embed coordinates
        .style("stroke-width", function (d) { return Math.max(1, d.dy); })
        // custom stroke color; defaulting to gray if not specified:
        .style("stroke", function (d) {
            // Priority order:
            // 1. color defined specifically for the flow
            // 2. inherit-from-source
            // 3. inherit-from-target
            return d.color ? d.color
                : d.source.inherit_right ? d.source.color
                : d.target.inherit_left ? d.target.color
                : '#666'; })
        .style("stroke-opacity", function (d) {
            return d.opacity || config_in.default_flow_opacity;
            })
        // add hover behavior:
        .on('mouseover', function(d){
            d3.select(this).style( "stroke-opacity",
                d.opacity_on_hover
                || ( ( Number(config_in.default_flow_opacity) + 1 ) / 2 ) );
            })
        .on('mouseout', function(d){
            d3.select(this).style( "stroke-opacity",
                d.opacity || config_in.default_flow_opacity );
            })
        // sets the order of display, seems like:
        .sort(function (a, b) { return b.dy - a.dy; });

    if ( !config_in.hide_labels ) {
        link.append("title") // Make tooltips for FLOWS
            .text(function (d) {
                return d.source.name + " â†’ " + d.target.name + "\n"
                    + units_format(d.value);
            });
    }

    // define drag function for use in node definitions
    function dragmove(d) {
        // Calculate new position:
        d.x = Math.max(0, Math.min(graph_width - d.dx, d3.event.x));
        d.y = Math.max(0, Math.min(graph_height - d.dy, d3.event.y));
        d3.select(this).attr(
            "transform",
            "translate(" + d.x + "," + d.y + ")"
        );
        // re-render:
        sankey.relayout();
        // re-write new flow metadata?
        link.attr("d", flow);
    }

    // Set up NODE info, behaviors:
    node = svg.append("g").selectAll(".node")
        .data(the_clean_json.nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; })
        .call(d3.behavior.drag()
            .origin(function (d) { return d; })
            .on("dragstart", function () { this.parentNode.appendChild(this); })
            .on("drag", dragmove)
            );

    // Construct actual rectangles for NODEs:
    node.append("rect")
        .attr("height", function (d) { return d.dy; })
        .attr("width", node_width)
        // we made sure above there will be a color defined:
        .style("fill", function (d) { return d.color; })
        .style("fill-opacity",
            function (d) {
                return d.opacity || config_in.default_node_opacity;
            })
        .style("stroke", function (d) { return d3.rgb(d.color).darker(2); })
        .append("title")    // Add tooltips for NODES
        .text(
            function (d) {
                return config_in.hide_labels
                    ? ""
                    : d.name + "\n" + units_format(d.value);
            });

    // Put in NODE labels
    node.append("text")
        // x,y = offsets relative to the node rectangle
        .attr("x", -6)
        .attr("y", function (d) { return d.dy / 2; })
        .attr("dy", ".35em")
        .attr("text-anchor", "end")
        .attr("transform", null)
        .text(
            function (d) {
                return config_in.hide_labels
                    ? ""
                    : d.name
                        + ( config_in.include_values_in_nodes
                            ? ": " + units_format(d.value)
                            : "" );
            })
        // In the left half of the picture, place labels to the right of nodes:
        .filter(function (d) { return d.x < graph_width / 2; })
        .attr("x", 6 + node_width)
        .attr("text-anchor", "start");
}


</script>

<div id="entirety">

<table><tr><td>

<form onsubmit="process_sankey(); return false;">

<table id="inputs">
<tr>
    <th id="title">SankeyMATIC
    <span style="margin:0; font-weight: normal; font-size:normal; font-style: italic;">alpha</span>
    </th>
</tr>
<tr>
    <td id="flows_entry">
    <textarea id="flows_in" rows="30" cols="40" onchange="process_sankey();"># To make a diagram:
# Type in a list of 'flows' in this format:
#     Source [Amount] Target
# Like these:

Here [8] Everywhere
There [5.5] Everywhere
Everywhere [5] Over there
Everywhere [6] Somewhere else

# To set a Color for a specific flow,
# add an HTML color code to the end of its line:
#     Source [Amount] Target #Color
# Like this:

Everywhere [2.5] Nearby #C00
Far far away [3] Nearby #909

# Click Preview below to update the graph

# Once you have your flows set up, use the
# options below to further change the graph's
# style.

# To see even more options, visit "Examples"
</textarea>
<p style="margin: auto; text-align: center;"><button id="preview_graph" type="submit">Preview</button></p>
</td>
</tr>

<tr>
<td id="other_entry">
<strong>Graph size:</strong>
<label for="canvas_width">Width =</label> <input type="text" id="canvas_width" size="5" maxlength="6" value="700" onchange="process_sankey();">
<label for="canvas_height">Height =</label> <input type="text" id="canvas_height" size="5" maxlength="6" value="400" onchange="process_sankey();">
<br />
<strong>Font size:</strong>
<input type="text" id="font_size" size="2" maxlength="4" value="12" onchange="process_sankey();"> <label for="font_size">px</label>
<br />
<br />
<strong>Units:</strong>
<label for="unit_prefix">Prefix =</label> <input type="text" id="unit_prefix" size="3" maxlength="10" onchange="process_sankey();">
<label for="unit_suffix">Suffix =</label> <input type="text" id="unit_suffix" size="5" maxlength="10" onchange="process_sankey();"><br />

<input type="checkbox" id="include_values_in_nodes" value="1" onchange="process_sankey();" checked="checked">
<label for="include_values_in_nodes">Show values as part of node labels</label><br />

<input type="checkbox" id="display_full_precision" value="1" onchange="process_sankey();">
<label for="display_full_precision">Always use full precision
<small>(e.g. for currency: $DD.cc)</small></label>
<br />
<br />
<strong>Inner Margin</strong> (pixels):<br />
<label for="top_margin">Top</label>
<input type="text" id="top_margin" size="3" maxlength="6" value="15" onchange="process_sankey();">
<label for="right_margin">Right</label>
<input type="text" id="right_margin" size="3" maxlength="6" value="15" onchange="process_sankey();">
<label for="bottom_margin">Bottom</label>
<input type="text" id="bottom_margin" size="3" maxlength="6" value="15" onchange="process_sankey();">
<label for="left_margin">Left</label>
<input type="text" id="left_margin" size="3" maxlength="6" value="15" onchange="process_sankey();">
<br />
<br />
<strong>Opacity for all...</strong><br />
<label for="default_flow_opacity">Flows:</label>
0.0<input id="default_flow_opacity" type="range" min="0" max="1" step="0.1" value="0.3" onchange="process_sankey();">1.0
<br />
<label for="default_node_opacity">Nodes:</label>
0.0<input id="default_node_opacity" type="range" min="0" max="1" step="0.1" value="0.9" onchange="process_sankey();">1.0
<br />
<br />
<input type="checkbox" id="hide_labels" value="1" onchange="process_sankey();">
<label for="hide_labels">Hide all labels</label><br />

</td>
</tr>
</table>

</form>

</td><td id="grapharea">

<table id="messages">
<tr><td id="messages_area"></td></tr>
</table>

<p id="chart">
<svg id="the_svg" height="400" width="700" xmlns="http://www.w3.org/2000/svg" version="1.1"></svg>
</p>

</td></tr></table>

<p id="questions" style="text-align: center;">
Questions? Bugs? Suggestions? Tell <a href="https://twitter.com/sankeymatic" target="_blank">@SankeyMATIC</a> on Twitter.
</p>

<p id="credits" style="text-align: center;">
SankeyMATIC is produced by <a href="http://nowthis.com/" target="_blank">Steve Bogart</a> (<a href="https://twitter.com/nowthis" target="_blank">@nowthis</a>).
It is built on top of the
<a href="http://bost.ocks.org/mike/sankey/" target="_blank">Sankey library</a> of <a
href="http://d3js.org/" target="_blank">D3.js</a>.
</p>

</div>

<script>
// render whatever we can on page load:
process_sankey();
</script>

</body></html>
