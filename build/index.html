<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SankeyMATIC &alpha;</title>
<link rel="stylesheet" href="main.css">
</head>
<body>

<!-- script src="http://d3js.org/d3.v2.min.js?2.9.1"></script -->
<script src="d3.v2.js"></script>
<script src="sankey.js"></script>
<script src="canvg.js"></script>
<script src="rgbcolor.js"></script>
<script>
function isNumeric(n) {
    // borrowed from jquery:
    /* "parseFloat NaNs numeric-cast false positives (null|true|false|"")
       ...but misinterprets leading-number strings, particularly hex literals ("0x...")
       subtraction forces infinities to NaN" */
    return n - parseFloat( n ) >= 0;
}

function escapeHtml(unsafe) {
    return unsafe
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

function remove_zeroes(number_string) {
    // Strip off zeros from after any decimal.
    // If no digits remain, remove the '.' as well.
    return number_string.replace( /(\.\d*?)0+$/, '$1' )
        .replace( /\.$/, '');
}

function update_png() {
    "use strict";
    // Since 'innerHTML' isn't supposed to work for XML (SVG) nodes (though it
    // does seem to in Firefox), we string together the node contents to submit
    // to the canvas converter:
    var svg_content
         = ( new XMLSerializer() ).serializeToString(
            document.getElementById("the_svg") ),
        canvas_context = '', svg_as_png_url = '',
        canvas_el = document.getElementById("png_preview"),
        png_link_el = document.getElementById("download_1x");

    // Draw the svg contents on the canvas:
    canvg( canvas_el, svg_content, {
        ignoreMouse: true,
        ignoreAnimation: true,
        useCORS: true,
        log: true
        } );

    // set background = white by drawing rect on entire canvas
    // credit to Mike Chambers (@mesh) for this approach:
    canvas_context = canvas_el.getContext("2d");
    canvas_context.globalCompositeOperation = "destination-over";
    canvas_context.fillStyle = "#FFFFFF";
    canvas_context.fillRect( 0, 0, canvas_el.width, canvas_el.height);

    // Convert canvas image to a PNG:
    svg_as_png_url = canvas_el.toDataURL('image/png');
    // make it downloadable
    svg_as_png_url = svg_as_png_url.replace('image/png','image/octet-stream');
    png_link_el.setAttribute( "href",  svg_as_png_url );
}

function process_sankey() {
    "use strict";
    var source_lines = [], good_flows = [], good_node_lines = [],
        bad_lines = [], node_order = [], line_ix = 0, line_in = '',
        unique_nodes = {}, matches = [], amount_in = 0,
        do_cross_checking = 1, cross_check_error_ct = 0,
        approved_nodes = [], approved_flows = [], approved_config = {},
        total_inflow = 0, total_outflow = 0, max_places = 0,
        epsilon_difference = 0, status_message = '', total_difference = 0,
        svg_content = '', canvas_el = '', chart_el = '',
        png_link_el = '', dimensions = '',
        messages_el = document.getElementById("messages_area"),
        png_link_el = document.getElementById("download_1x"),
        raw_flows_var = document.getElementById("flows_in").value;

    // Define utility functions:
    // Put a message on the page using the specified class:
    function add_message( msg_class, msg_html, at_beginning ) {
        var new_msg = '<p class="' + msg_class + '">' + msg_html + '</p>';
        if (at_beginning) {
            messages_el.innerHTML = new_msg + messages_el.innerHTML;
        } else {
            messages_el.innerHTML = messages_el.innerHTML + new_msg;
        }
    }

    // Format a value as it will be in the graph. Uses approved_config and
    // max_places
    function unit_fy(number_in) {
        var number_portion = d3.format( ",." + max_places + "f" )(number_in);
        return approved_config.unit_prefix
            + ( approved_config.display_full_precision
                ? number_portion
                : remove_zeroes(number_portion) )
            + approved_config.unit_suffix;
    }

    // BEGIN by resetting all messages:
    messages_el.innerHTML = '';
    png_link_el.innerHTML = "...";

    // Go through lots of validation with plenty of bailout points and
    // informative messages for the poor soul trying to do this.

    // Flows validation:

    // parse into structures: approved_nodes, approved_flows, approved_config
    source_lines = raw_flows_var.split("\n");

    // parse all the input lines, storing good ones vs bad ones:
    for ( line_ix = 0; line_ix < source_lines.length; ++line_ix ) {
        // Does this line match the basic format?
        line_in = source_lines[line_ix].trim();
        // Is it a comment? Skip it entirely:
        if ( line_in.match(/^'/) ) {
            continue;
        }
        // Is it a node spec?
        matches = line_in.match(
                /^:(.+) #([0-9A-F]{0,6})?(\.\d{1,4})?\s*(>>|<<)*\s*(>>|<<)*$/i );
        if ( matches !== null ) {
            good_node_lines.push(
                { 'name' : matches[1].trim(),
                  'color' : matches[2],
                  'opacity' : matches[3],
                  'inherit1' : matches[4],
                  'inherit2' : matches[5]
                } );
            continue;
        }
        matches = line_in.match( /^(.+)\[([\d\.\s\+\-]+)\](.+)$/ );
        if ( matches !== null ) {
            // The Amount looked like a number; is it really (after tossing out
            // whitespace)?
            amount_in = matches[2].replace(/\s/g,'');
            if ( !isNumeric(amount_in) ) {
                bad_lines.push (
                    { 'value' : line_in,
                      'message' : 'The Amount is not a valid decimal number.' } );
            } else if (amount_in <= 0) {
                // The Sankey library doesn't currently support negative numbers or 0:
                bad_lines.push (
                    { 'value' : line_in,
                      'message' : 'Amounts must be greater than 0.' } );
            } else {
                // All seems well, save it as good (even if 0):
                good_flows.push(
                    { 'source' : matches[1].trim(),
                      'target' : matches[3].trim(),
                      'amount' : amount_in } );
                // We need the maximum precision of the inputs (# of characters
                // to the RIGHT of the decimal) for some error checking
                // operations (& display) later:
                max_places =
                    Math.max( max_places,
                        ( ( amount_in.split( /\./ ) )[1] || '' ).length );
            }
        } else if ( line_in !== '' ) {
            // There was input, but something made it not match the pattern:
            bad_lines.push(
                { 'value' : line_in,
                  'message' :
                    'The line is not in the format: Source [Amount] Target' }
            );
        }
        // else, the final case: a blank line. We just skip those silently, so
        // someone can separate their input lines with whitespace if desired.
    }
    // We know max_places now, so we can derive the smallest important difference:
    epsilon_difference = Math.pow( 10, -max_places - 1 );

    // TODO: Look for cycles and post errors about them

    // Mention the bad lines in the message area:
    bad_lines.forEach( function(parse_error) {
        add_message('errormessage',
            '&quot;<b>' + escapeHtml(parse_error.value) + '</b>&quot;: ' +
             parse_error.message, 0);
    });

    // save_node: Add a node to the unique list (if it's not there already):
    function save_node( nodename, nodeparams ) {
        // Have we NOT seen this node before? Then add it:
        if ( !unique_nodes.hasOwnProperty(nodename) ) {
            // establish the hash:
            unique_nodes[nodename] = {
                "from_sum": 0,   "to_sum": 0,
                "from_list": [], "to_list": [],
                "index": node_order.length
            };
            node_order.push(nodename);
        }
        // Even if we have seen a node, there still may be more parameters
        // to add to its spec:
        if ( typeof nodeparams === "object" ) {
            Object.keys(nodeparams).forEach( function(p) {
                // console.log(nodename, p,
                //    unique_nodes[nodename].hasOwnProperty(p) );
                if ( nodeparams[p] !== null && nodeparams[p] !== "" ) {
                    // Note: If there are multiple lines specifying the same
                    // param for a node, the last one will win:
                    unique_nodes[nodename][p] = nodeparams[p];
                }
            } );
        }
    }

    // First go through the Node list and set up any extra parameters we have:
    good_node_lines.forEach( function(node) {
        // If there's a color and it's a color CODE, put back the #:
        if ( node.color && node.color.match( /[0-9A-F]{3,6}/i ) ) {
            node.color = '#' + node.color;
        }
        save_node( node.name, node );
    } );

    // Given good_flows, make the lists of nodes and flows
    good_flows.forEach( function(flow) {
        // Look for extra content about this flow on the target-node end of the
        // string:
        var possible_color, possible_nodename, flow_color = "",
            opacity = "", opacity_on_hover = "";
        // Try to parse; there may be extra info that isn't actually the name:
        // Format of the Target node can be:
        // TODO: Target node ["Custom name for flow"] [#color[.opacity]]
        // e.g. Clinton #CCDDEE
        // e.g. Gondor "Legolas" #998877.25
        // Look for an additional string starting with # for color info
        matches = flow.target.match( /^(.+)\s+(\#\S+)$/ );
        if ( matches !== null ) {
            // IFF the # string matches the pattern, separate the nodename
            // into parts. Assume a color will have at least 3 digits (rgb).
            possible_nodename = matches[1];
            possible_color    = matches[2];
            matches = possible_color.match(
                /^#([0-9A-F]{3,6})?(\.\d{1,4})?$/i );
            if ( matches !== null ) {
                // We got matches; rewrite the node & interpret the extra data
                flow.target = possible_nodename;
                // Was there a color spec?
                if ( matches[1] ) {
                    flow_color = '#' + matches[1];
                }
                // Was there an opacity argument?
                if ( matches[2] ) {
                    opacity = matches[2];
                    // Make the hover opacity halfway between opacity and 1:
                    opacity_on_hover = ( Number(opacity) + 1 ) / 2;
                }
            }
            // Otherwise we just treat it as part of the nodename
        }
        save_node(flow.source);
        save_node(flow.target);

        // Add the encoded flow to the list of approved flows:
        approved_flows.push({
            "source": unique_nodes[flow.source].index,
            "target": unique_nodes[flow.target].index,
            "value": flow.amount,
            "color": flow_color,
            "opacity": opacity,
            "opacity_on_hover": opacity_on_hover
            }
        );
        // Save useful information for the flow cross-check:
        unique_nodes[flow.source].from_sum += Number(flow.amount);
        unique_nodes[flow.source].from_list.push(flow.amount);
        unique_nodes[flow.target].to_sum += Number(flow.amount);
        unique_nodes[flow.target].to_list.push(flow.amount);
    });

    // Construct the approved_nodes structure:
    node_order.forEach( function (nodename) {
        var this_node = unique_nodes[nodename],
            readynode = {
                "name": nodename,
                "index": this_node.index,
                "color": this_node.color,
                "opacity": this_node.opacity,
                "inherit_right":
                    ( this_node.inherit1 === ">>"
                        || this_node.inherit2 === ">>" ? 1 : 0 ),
                "inherit_left":
                    ( this_node.inherit1 === "<<"
                        || this_node.inherit2 === "<<" ? 1 : 0 )
            };

        // approved_nodes = the real node list, formatted for the render routine:
        approved_nodes.push(readynode);
    });

    // Get & fill in the config.
    // Why now? For one thing, we need the Units for the messages we make below.
    // First fill in basic defaults. Values from the form will override if present.
    approved_config = {
        unit_prefix: "",
        unit_suffix: "",
        max_places: max_places,
        display_full_precision: 0,
        include_values_in_nodes: 0,
        hide_labels: 0,
        canvas_width: 700,
        canvas_height: 400,
        font_size: 12,
        font_weight: 400,
        top_margin: 10, right_margin: 10, bottom_margin: 10, left_margin: 10,
        default_flow_opacity: 0.3,
        default_node_opacity: 0.9,
        node_width: 10,
        node_padding: 10
    };

    // Plain strings:
    (["unit_prefix", "unit_suffix"]).forEach( function(field_name) {
        var field_val = document.getElementById(field_name).value;
        // console.log(field_name, field_val);
        if (field_val.length < 10) {
            approved_config[field_name] = field_val;
        }
    });
    // Whole positive numbers:
    ([ "canvas_width", "canvas_height", "font_size",
        "top_margin","right_margin", "bottom_margin",
        "left_margin", "font_weight" ]).forEach( function(field_name) {
        var field_val = document.getElementById(field_name).value;
        // console.log(field_name, field_val);
        if (field_val.length < 10 && field_val.match(/^\d+$/)) {
            approved_config[field_name] = field_val;
        }
    });
    // Checkboxes:
    (["display_full_precision","include_values_in_nodes",
        "hide_labels"]).forEach( function(field_name) {
        approved_config[field_name] = document.getElementById(field_name).checked;
        // console.log(field_name, approved_config[field_name]);
    });
    // Decimal:
    (["default_node_opacity","default_flow_opacity"]).forEach( function(field_name) {
        var field_val = document.getElementById(field_name).value;
        if ( field_val.match(/^\d(?:.\d+)?$/) ) {
            approved_config[field_name] = field_val;
        }
        // console.log( field_name, field_val, approved_config[field_name] );
    });

    do_cross_checking = document.getElementById("flow_cross_check").checked;

    // Given the canvas size, adjust the size of the containing element:
    chart_el = document.getElementById('chart');
    chart_el.style.height = approved_config.canvas_height + "px";
    chart_el.style.width = approved_config.canvas_width + "px";

    // Flow cross-check: Test if the total INTO a node is equal to the amount
    // OUT OF it; warn the user if not:
    node_order.forEach( function(nodename) {
        var this_node = unique_nodes[nodename], difference;
        // Skip any nodes with 0 as the From or To amount; those are the
        // starting & ending nodes for the whole graph:
        if ( this_node.from_sum > 0 && this_node.to_sum > 0) {
            difference = this_node.to_sum - this_node.from_sum;
            // Is the difference great enough to matter? (i.e. bigger than 1/10
            // the smallest unit used?)
            if ( do_cross_checking
                && Math.abs(difference) >= epsilon_difference ) {
                // Construct a hyper-informative error message about the
                // imbalance.
                // If we don't round the outputs to match the maximum precision
                // of the inputs, we get uselessly long repeated decimals:
                cross_check_error_ct++;
                add_message( "cautionmessage",
                    "&quot;<b>" + escapeHtml(nodename) + "</b>&quot;: " +
                    "The amount <strong>IN</strong> (" +
                    '<dfn title="' +
                    this_node.to_list.join(' + ') + '">' +
                    unit_fy(this_node.to_sum) +
                    "</dfn>) does not match the amount <strong>OUT</strong> (" +
                    '<dfn title="' +
                    this_node.from_list.join(' + ') + '">' +
                    unit_fy(this_node.from_sum) +
                    "</dfn>). &Delta; = <strong>" +
                    unit_fy(difference) + "</strong>.", 0 );
            }
        } else {
            // One of these values will be 0 every time, but so what...
            total_inflow += this_node.from_sum;
            total_outflow += this_node.to_sum;
        }
    });

    // Are there any good flows at all? If not, offer help:
    if ( good_flows.length === 0 ) {
        add_message('okmessage',
            'Enter a list of flows (one per line). See the Examples page.', 0);
        // No point in proceeding any further:
        return null;
    }

    status_message = "Showing: <strong>" + approved_flows.length +
        " flows</strong> between <strong>" + approved_nodes.length +
        " nodes</strong>.";
    total_difference = total_inflow - total_outflow;
    if ( Math.abs(total_difference) < epsilon_difference ) {
        status_message +=
            " Total IN = Total OUT = <strong>"
            + unit_fy(total_inflow) + "</strong>.";
    } else if (do_cross_checking) {
        // Leave out the differing totals from the status message, issue a
        // Caution instead:
        add_message( "cautionmessage",
            "The <strong>Total IN</strong> (" +
            unit_fy(total_inflow) +
            ") does not match the <strong>Total OUT</strong> (" +
            unit_fy(total_outflow) +
            "). &Delta; = <strong>" + unit_fy(total_difference) + "</strong>.",
            0 );
    } else {
        status_message +=
            " Total <strong>IN</strong> = <strong>"
            + unit_fy(total_inflow) + "</strong>. Total <strong>OUT</strong> = <strong>"
            + unit_fy(total_outflow) + "</strong>.";
    }
    if (do_cross_checking) {
        if ( cross_check_error_ct > 0 ) {
            status_message += " Imbalances found:";
        } else {
            status_message += " No imbalances found.";
        }
    } else {
        status_message += " Flow Cross-Check is <strong>OFF</strong>.";
    }
    add_message( "okmessage", status_message, 1 ); // always display main status line first

    // Do the actual rendering:
    render_sankey( approved_nodes, approved_flows, approved_config );

    update_png();

    // update download link & filename with dimensions:
    dimensions
        = approved_config.canvas_width + "x" + approved_config.canvas_height;
    png_link_el.innerHTML = "Download " + dimensions + " PNG";
    png_link_el.setAttribute( "download", "sankey_" + dimensions + ".png" );

    return null;
}

function render_sankey(nodes_in, flows_in, config_in) {
    "use strict";

    var graph_width, graph_height,
        units_format, d3_color_scale, svg, sankey, flow, link, node,
        node_width    = config_in.node_width,
        node_padding  = config_in.node_padding,
        total_width   = config_in.canvas_width,
        total_height  = config_in.canvas_height,
        margin_top    = config_in.top_margin,
        margin_bottom = config_in.bottom_margin,
        margin_left   = config_in.left_margin,
        margin_right  = config_in.right_margin;

    config_in.unit_prefix =
        ( typeof config_in.unit_prefix === "undefined"
            || config_in.unit_prefix === null )
            ? "" : config_in.unit_prefix;
    config_in.unit_suffix =
        ( typeof config_in.unit_suffix === "undefined"
            || config_in.unit_suffix === null)
            ? "" : config_in.unit_suffix;

    // Establish a list of 20 compatible colors to choose from:
    d3_color_scale = d3.scale.category20();

    // Fill in any missing node colors up front so they can be inherited from:
    nodes_in.forEach( function(node) {
        if (typeof node.color === 'undefined' || node.color === '') {
            // Use the first word of the label as the basis for
            // finding an already-used color or picking a new one (case
            // sensitive).
            // If there are no 'word' characters, substitute a word-ish value
            // (rather than crash):
            var first_word = ( /^\W*(\w+)/.exec(node.name) || ['','not a word'] )[1];
            node.color = d3_color_scale(first_word);
        }
    });

    var the_clean_json = {
        "nodes": nodes_in,
        "links": flows_in
    };

    // Set the dimensions of the space:
    graph_width = total_width - margin_left - margin_right;
    graph_height = total_height - margin_top - margin_bottom;

    // *&*&*&* TODO: Does this function really need to be assigned to a variable?
    units_format = function (d) {
        var number_portion = d3.format( ",." + config_in.max_places + "f" )(d);
        return config_in.unit_prefix
            + ( config_in.display_full_precision
                ? number_portion
                : remove_zeroes(number_portion) )
            + config_in.unit_suffix;
    };

    // clear out any old contents:
    // Simply emptying the SVG tag didn't work well in Safari; we reset the whole tag here:
    document.getElementById('chart').innerHTML =
        '<svg id="the_svg" height="400" width="700" xmlns="http://www.w3.org/2000/svg" version="1.1"></svg>';

    // Select the svg canvas, set the defined dimensions:
    svg = d3.select("#the_svg")
        .attr("width", total_width)
        .attr("height", total_height)
        .append("g")
        .attr("transform", "translate(" + margin_left + "," + margin_top + ")");

    // create a sankey object & its properties..
    sankey = d3.sankey()
        .nodeWidth(node_width)
        .nodePadding(node_padding)
        .size([graph_width, graph_height])
        .nodes(the_clean_json.nodes)
        .links(the_clean_json.links)
        .layout(32);

    // flow is a function returning coordinates and specs for each flow area
    flow = sankey.link();

    link = svg.append("g").selectAll(".link")
        .data(the_clean_json.links)
        .enter()
        .append("path")
        .attr("class", "link")
        .attr("d", flow) // embed coordinates
        .style("fill", "none") // ensure no line gets drawn, just stroke
        .style("stroke-width", function (d) { return Math.max(1, d.dy); })
        // custom stroke color; defaulting to gray if not specified:
        .style("stroke", function (d) {
            // Priority order:
            // 1. color defined specifically for the flow
            // 2. inherit-from-source
            // 3. inherit-from-target
            return d.color ? d.color
                : d.source.inherit_right ? d.source.color
                : d.target.inherit_left ? d.target.color
                : '#666'; })
        .style("stroke-opacity", function (d) {
            return d.opacity || config_in.default_flow_opacity;
            })
        // add hover behavior:
        .on('mouseover', function(d){
            d3.select(this).style( "stroke-opacity",
                d.opacity_on_hover
                || ( ( Number(config_in.default_flow_opacity) + 1 ) / 2 ) );
            })
        .on('mouseout', function(d){
            d3.select(this).style( "stroke-opacity",
                d.opacity || config_in.default_flow_opacity );
            })
        // sets the order of display, seems like:
        .sort(function (a, b) { return b.dy - a.dy; });

    if ( !config_in.hide_labels ) {
        link.append("title") // Make tooltips for FLOWS
            .text(function (d) {
                return d.source.name + " â†’ " + d.target.name + "\n"
                    + units_format(d.value);
            });
    }

    // define drag function for use in node definitions
    function dragmove(d) {
        // Calculate new position:
        d.x = Math.max(0, Math.min(graph_width - d.dx, d3.event.x));
        d.y = Math.max(0, Math.min(graph_height - d.dy, d3.event.y));
        d3.select(this).attr(
            "transform", "translate(" + d.x + "," + d.y + ")"
        );
        // re-render:
        sankey.relayout();
        // rewrite the flow's data:
        link.attr("d", flow);
        // regenerate the static version, incorporating the drag:
        update_png();
    }

    // Set up NODE info, behaviors:
    node = svg.append("g").selectAll(".node")
        .data(the_clean_json.nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; })
        .call(d3.behavior.drag()
            .origin(function (d) { return d; })
            .on("dragstart", function () { this.parentNode.appendChild(this); })
            .on("drag", dragmove)
            );

    // Construct actual rectangles for NODEs:
    node.append("rect")
        .attr("height", function (d) { return d.dy; })
        .attr("width", node_width)
        // we made sure above there will be a color defined:
        .style("fill", function (d) { return d.color; })
        .style("fill-opacity",
            function (d) {
                return d.opacity || config_in.default_node_opacity;
            })
        .style( "stroke-width", "0" )
        //.style("stroke", function (d) { return d3.rgb(d.color).darker(2); })
        .append("title")    // Add tooltips for NODES
        .text(
            function (d) {
                return config_in.hide_labels
                    ? ""
                    : d.name + "\n" + units_format(d.value);
            });

    // Put in NODE labels
    node.append("text")
        // x,y = offsets relative to the node rectangle
        .attr("x", -6)
        .attr("y", function (d) { return d.dy / 2; })
        .attr("dy", ".35em")
        .attr("text-anchor", "end")
        .attr("transform", null)
        .text(
            function (d) {
                return config_in.hide_labels
                    ? ""
                    : d.name
                        + ( config_in.include_values_in_nodes
                            ? ": " + units_format(d.value)
                            : "" );
            })
        .style( {   // be explicit about the font specs:
            "font-size": config_in.font_size + "px",
            "font-family": "helvetica, sans-serif",
            "stroke-width": "0", // positive stroke-width makes letters fuzzy
            "font-weight": config_in.font_weight,
            } )
        // In the left half of the picture, place labels to the right of nodes:
        .filter(function (d) { return d.x < graph_width / 2; })
        .attr("x", 6 + node_width)
        .attr("text-anchor", "start");
}


</script>

<div id="entirety">

<table><tr><td>

<form onsubmit="process_sankey(); return false;">

<table id="inputs">
<tr>
    <th id="title">SankeyMATIC
    <span style="margin:0; font-weight: normal; font-size:normal; font-style: italic;">alpha</span>
    </th>
</tr>
<tr>
    <td id="flows_entry">
    <textarea id="flows_in" rows="25" cols="40" onchange="process_sankey();">' To get started, type a list of "flows" like this:
'     Source [Amount] Target
' Examples:
Here [8] Everywhere
There [5.5] Everywhere
Everywhere [5] Over there
Everywhere [6] Somewhere else

' To set a color for a specific flow, add an
' HTML color code to the end:
'     Source [Amount] Target #Color
' Examples:
Everywhere [2.5] Nearby #C00
Far far away [3] Nearby #0C0

' To set a node's color and make the flows in
' (or out) adopt its color:
'     :Nodename #Color &gt;&gt; &lt;&lt;
' Example:
:There #FC0 >>

' Once you have your nodes &amp; flows, use the
' controls below to further change the
' graph's style.</textarea>
<p style="margin: auto; text-align: center;"><button id="preview_graph" type="submit">Preview</button></p>
</td>
</tr>

<tr>
<td id="other_entry">
<strong>Graph size:</strong>
<label for="canvas_width">Width =</label> <input type="text" id="canvas_width" size="5" maxlength="6" value="700" onchange="process_sankey();">
<label for="canvas_height">Height =</label> <input type="text" id="canvas_height" size="5" maxlength="6" value="400" onchange="process_sankey();">
<br />
<span style="line-height: 0;"><strong>Font:</strong> Size</span>
<input type="text" id="font_size" size="2" maxlength="4" value="12" onchange="process_sankey();"> <label for="font_size">px</label>

&nbsp;&nbsp;&nbsp;<span style="font-weight: lighter;" class="smalllabel">Light</span><input id="font_weight" type="range" min="100" max="700" step="300" value="400" onchange="process_sankey();" class="narrowslider"><span style="font-weight: bolder;" class="smalllabel">Bold</span>
<br />
<strong>Labels:</strong>
<label for="unit_prefix">Units Prefix =</label> <input type="text" id="unit_prefix" size="3" maxlength="10" onchange="process_sankey();">
<label for="unit_suffix">Suffix =</label> <input type="text" id="unit_suffix" size="5" maxlength="10" onchange="process_sankey();"><br />

<input type="checkbox" id="include_values_in_nodes" value="1" onchange="process_sankey();" checked="checked">
<label for="include_values_in_nodes">Show values as part of node labels</label>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" id="display_full_precision" value="1" onchange="process_sankey();">
<label for="display_full_precision">Always use full precision
<small>(e.g. for currency: $DD.cc)</small></label>
<br />
<input type="checkbox" id="hide_labels" value="1" onchange="process_sankey();">
<label for="hide_labels">Hide labels</label> <small>(to apply your own text to the graph)</small><br />
<br />
<strong>Inner Margin</strong> (pixels):<br />
<label for="top_margin">Top</label>
<input type="text" id="top_margin" size="3" maxlength="6" value="15" onchange="process_sankey();">
<label for="right_margin">Right</label>
<input type="text" id="right_margin" size="3" maxlength="6" value="15" onchange="process_sankey();">
<label for="bottom_margin">Bottom</label>
<input type="text" id="bottom_margin" size="3" maxlength="6" value="15" onchange="process_sankey();">
<label for="left_margin">Left</label>
<input type="text" id="left_margin" size="3" maxlength="6" value="15" onchange="process_sankey();">
<br />
<br />
<strong>Opacity for all...</strong><br />
&nbsp;&nbsp;&nbsp;&nbsp;<label for="default_flow_opacity">Flows:</label>
<span class="smalllabel">0.0</span><input id="default_flow_opacity" type="range" min="0" max="1" step="0.1" value="0.3" onchange="process_sankey();" class="narrowslider"><span class="smalllabel">1.0</span>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<label for="default_node_opacity">Nodes:</label>
<span class="smalllabel">0.0</span><input id="default_node_opacity" type="range" min="0" max="1" step="0.1" value="0.9" onchange="process_sankey();" class="narrowslider"><span class="smalllabel">1.0</span>
<br />
<br />
<input type="checkbox" id="flow_cross_check" value="1" onchange="process_sankey();" checked="checked">
<label for="flow_cross_check"><strong>Flow Cross-Check:</strong> Verify that the graph adds up.</label><br />

</td>
</tr>
</table>

</form>

</td><td id="grapharea">

<table id="messages">
<tr><td id="messages_area"></td></tr>
</table>

<p id="chart">
<svg id="the_svg" height="400" width="700" xmlns="http://www.w3.org/2000/svg" version="1.1"></svg>
</p>
<canvas id="png_preview" height="400" width="700" style="background: #FFF; display:none;"></canvas>
<div id="chartfooter">
<p>Note: you can drag nodes around if you want to make some small adjustments. (Changing any inputs will re-draw the graph, however.)</p>
<p>Once you are satisfied with your graph, you can <strong>export it as a .PNG image</strong>:</p>
<p><a href="#" id="download_1x" download="sankey_1x.png">...</a></p>
</div>
</td></tr></table>

<p id="questions" style="text-align: center;">
Questions? Bugs? Suggestions? Tell <a href="https://twitter.com/sankeymatic" target="_blank">@SankeyMATIC</a> on Twitter.
</p>

<p id="credits" style="text-align: center;">
SankeyMATIC is produced by <a href="http://nowthis.com/" target="_blank">Steve Bogart</a> (<a href="https://twitter.com/nowthis" target="_blank">@nowthis</a>).
It is built on top of the
<a href="http://bost.ocks.org/mike/sankey/" target="_blank">Sankey library</a> of <a
href="http://d3js.org/" target="_blank">D3.js</a>.
</p>

</div>

<script>
process_sankey(); // render on page load
</script>

</body></html>
